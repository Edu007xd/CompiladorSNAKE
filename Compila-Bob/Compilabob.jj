/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\Compilabob.jj */
/*@egen*/options { 
               
	JAVA_UNICODE_ESCAPE = true; 
	KEEP_LINE_COLUMN = true; 
	STATIC = false; 
} 

/*
GRAMATICAS PARA AGREGAR LOS NODOS EN EL ARBOL
Muestra (Salamanca)
 concatenacion (eduardo)
comparadores (gussher)

PASOS A REALIZAR PARA AGREGAR LOS NODOS AL ARBOL

1-  HACER LOS CAMBIOS EN Compilabob.jjt dentro de cada gramatica
		Token t; ---->    t = <LEXEMA>  ----> jjtThis.setName(t.image);
2-  EJECUTAR EL COMANDO jjtree Compilabob.jjt para obtener las clases de cada nodo:
		 ej. ASTVariable_dato.java
3-	Hacer los cambios en el programa, como crear el metodo SetName(String value)

4-	Ejecutar los otros comandos en busca de posibles errores



**COMANDOS
jjtree Compilabob.jjt
javacc Compilabob.jj

** este compila los archivos java generados en busca de errores
javac *.java 
** los codigos con el lenguaje creado a ser analizados
java Compilabob < Ejemplo7.txt
java Compilabob < t1.txt





----------------------------------------------------------------  NOTA --------------------------------------------------------------------------
---------------------------------------------------------- codigo --------------------------------------------------------------------

M\u00c3\u00a9todo de error "=" en lugar de ":" para las asignaciones.
Resolver el break de estructuras por el m\u00c3\u00a9todo SKIP
		Quiz\u00c3\u00a1s funcione ampliando el rango de error hasta llaves de abertura y cierre junto a los punto y coma.
*/

PARSER_BEGIN(Compilabob) 

import java.util.*;
import java.io.*;

public class Compilabob/*@bgen(jjtree)*/implements CompilabobTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCompilabobState jjtree = new JJTCompilabobState();

/*@egen*/  

	//********************
	public static Hashtable ST  = new Hashtable();
	String temp;
	STC temp2;

	String errormsg="",datos = "";
	static  String expresion =" "; 
	int sentencias_inco =0;  
	//variables para semantica-------------------------------
    String Type="", Valor=""; //variables cache para capturar el par
    String lugar = "";
	Token var;
    //--------------------------------------------------------
	public static void main(String args[])  { 
		Compilabob compilador = new Compilabob(System.in); 
		try { 
			SimpleNode e = compilador.Codigo();
			e.dump(">");



			/* *******************
			Enumeration t = ST.keys();
			while(t.hasMoreElements() == true){
				temp = (String)t.nextElement
			}
			*/

		}catch(ParseException pe){
            pe.printStackTrace();
        }
        catch( Exception e ){   
			System.out.println("\nEXCEPTION e MAIN\n" +"Sentencias incorrectas encontradas: "+compilador.sentencias_inco);
		}
		catch( TokenMgrError e ) { 
			System.out.println( "Error de Token" );
		} 
		if(compilador.errormsg == "\n" && compilador.sentencias_inco == 0){
			System.out.println("An"+"\u00e1"+"lisis l"+"\u00e9"+"xico y sint"+"\u00e1"+"ctico ejecutados con "+"\u00e9"+"xito");
		}else{
			System.out.println(compilador.errormsg);
		}
		System.out.println("PILA SEMANTICA CREADA EXITOSAMENTE");
		System.out.println("FINAL PRINT\n" +"Sentencias incorrectas encontradas: "+compilador.sentencias_inco);
		System.out.println("----- Tabla de simbolos ----\n"+ ClaseSemantica.tabla);
		ClaseSemantica.Crear_txt();
		//System.out.println("EXPRESION ----- : "+expresion);
	} 
    // {jjtThis.setImage(t.image);}
	
	
}   

PARSER_END(Compilabob)   
  
SKIP :   
{  
	< " " | "\t" | "\r" | "\n" | "\r\n" >  //White space 1
	| <"#" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >  //Single-line comments 2
	| <"##"(~["/"])*  "#""#" >  //Multi-line comments  3 ---- 
}

TOKEN:   
{   
<INICIO: "compilar_coatl">  //4
|<FIN: "ejecutar_coatl">  //5
|<IF: "decide">   //6
|<ELSE: "sino">   //7
|<CicloIterado: "repito hasta que">  //8
|<CicloLimit: "repito"> //9
|<CicloWhile: "mientras">  //10
|<ESCRIBIR: "muestra">//11
|<LEER:"recibir">//12
}  

TOKEN:   
{   
<ParenIzq: "(">  //13 - 
|<ParenDer: ")"> //14
|<SepIzq: "{">  //15
|<SepDer: "}" >  //16 
|<PuntoComa: ";"> //17
|<COMA: ",">  //18
}  

TOKEN:  
{  
<ASIGNACION: ":"> //19
|<MENOR: "<">  //20
|<MAYOR: ">"> //21
|<MENOR_IGUAL: "<=">//22
|<MAYOR_IGUAL: ">="> //23
|<IGUALDAD: "="> //24
|<OR: "|">  //25
|<AND: "&"> //26
|<NOTEQ: "!="> //27
|<NOT: "!"> //28
|<MAS: "+"> //29
|<MENOS: "-"> //30
|<DIV: "/"> //31
|<MODULO: "%"> //32
|<MULTI: "*"> //33
}   
// [("E_")(["a"-"z"|"A"-"Z"|"_"|"0"-"9"])+]  
//"E_"(["A"-"Z","a"-"z"](["A"-"Z","a"-"z","0"-"9"])*)  
// NOT ~ 

//<CADENAS: ("\""(~["\"","#","\n","\r","#","#","\r","\n"])*"\"")>//31
//Token t = getToken();
	//expresion = expresion + t.image;

TOKEN: 
{ 
<ENTERO: "E_">//34
|<FLOTANTE: "D_">//35
|<ID_CADENA: "C_">//36
|<BOOLEANO: "L_">//37
|<NUMERO: (["0"-"9"])+>//38
|<NUMDECIMAL: (["0"-"9"])+ "." (["0"-"9"])+ | (["0"-"9"])+ "." | "." (["0"-"9"])+>//39
|<CADENAS: ("\""(~["\"","#","\n","\r","#","#","\r","\n"])*"\"")>//40
|<EST_LOGIC:("falso"|"verdad")>//41
}   

TOKEN: 
{
	<IDENTIFICADOR:["A"-"Z","a"-"z"](["A"-"Z","a"-"z","0"-"9"])*>//42

}

TOKEN: 
{ 
	<UNKNOW : ~[]> //43
}


 
//------------------------------- AN\u00c3\ufffdLISIS SINTACTICO - AREA DE GRAMATICAS ----------------------------------------------------

// Gramatica inicial que contiene el cuerpo basico del codigo
SimpleNode Codigo():
{/*@bgen(jjtree) Codigo */
        ASTCodigo jjtn000 = new ASTCodigo(JJTCODIGO);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/	//Se inicializan las tablas donde seran referencia para verrificar validez semantica
	ClaseSemantica.SetTables();	
} 
{/*@bgen(jjtree) Codigo */
        try {
/*@egen*/
	((<INICIO> |ErrorNoinicio())(<SepIzq> |ErrorNoSepINICIO())) 
	Cuerpo() 
	((<SepDer>|ErrorNoSepFINAL())(<FIN>|ErrorNOFIN()))<EOF>/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

// m\u00c3\u00a9todo cuerpo, lee un conjunto de sentencias tama\u00c3\u00b1o n
void Cuerpo():{/*@bgen(jjtree) Cuerpo */
  ASTCuerpo jjtn000 = new ASTCuerpo(JJTCUERPO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Cuerpo */
try {
/*@egen*/ 
(sentencias())*/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/ 
} 

// metodo sentencias, lee todas las gramaticas que pueden ser reconocidas por el compilador
void sentencias():{/*@bgen(jjtree) sentencias */
  ASTsentencias jjtn000 = new ASTsentencias(JJTSENTENCIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) sentencias */
try {
/*@egen*/ 
try {
(LOOKAHEAD(2) 
 // PuntoComa toen separado debido a la variabilidad del codigo
Declaracion()   // Declaracion de Variables k
|( Asignacion()( <PuntoComa>|errorFinlinea())) //Asignacion de valores 
| Ciclo_RepitoHastaQue() 
| Ciclo_RepitoMientras()
| Decide()
| Muestra()
| error()
| errorDOBLElinea()
  )
}
catch (ParseException e) {
	System.out.println(e.toString());  //imprime el mensaje de error
    error_skipto(PuntoComa, FIN, EOF);
  }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/ 

}


void Muestra():{/*@bgen(jjtree) Muestra */
  ASTMuestra jjtn000 = new ASTMuestra(JJTMUESTRA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/   }
{/*@bgen(jjtree) Muestra */
        try {
/*@egen*/

	<ESCRIBIR> {} <ParenIzq>  Mensaje()   <ParenDer> (<PuntoComa>|errorFinlinea())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Mensaje():{/*@bgen(jjtree) Mensaje */
  ASTMensaje jjtn000 = new ASTMensaje(JJTMENSAJE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Mensaje */
        try {
/*@egen*/

	Concatenacion() |/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ {}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Concatenacion():{/*@bgen(jjtree) Concatenacion */
  ASTConcatenacion jjtn000 = new ASTConcatenacion(JJTCONCATENACION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Concatenacion */
  try {
/*@egen*/
// Crear una variable auxiliar como Variable_IDEN() para <cadenas> y <mas>, 
// tambien alterar las clases que se generen
  ( LOOKAHEAD(2)
  	( (Variable_IDEN()|<CADENAS>) <MAS>  Concatenacion() ) | (Variable_IDEN()|<CADENAS>))/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
} 





//----------------------------------------------------------------------------------------------
//########  DECIDE IF-ELSE ##########
void Decide():{/*@bgen(jjtree) Decide */
  ASTDecide jjtn000 = new ASTDecide(JJTDECIDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Decide */
try {
/*@egen*/
IF() ( 
	LOOKAHEAD(2)
	ELSE()|/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/{})/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}
void IF():{/*@bgen(jjtree) IF */
  ASTIF jjtn000 = new ASTIF(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) IF */
        try {
/*@egen*/
	<IF> <ParenIzq> OpComparacion() <ParenDer>  <ASIGNACION>  <SepIzq>
	(	 
	sentencias() )*
	<SepDer>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ELSE():{/*@bgen(jjtree) ELSE */
  ASTELSE jjtn000 = new ASTELSE(JJTELSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ELSE */
        try {
/*@egen*/
	<ELSE> <SepIzq> 
	(	 
	sentencias() )*<SepDer> (<PuntoComa>|errorFinlinea())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


// ############## CICLOS #############
//----------------------------------------------------------------------------------------------------------------------

//No es necesario aqui agregar un jjtThis.setName(t.image);
//debido a que solo necesitamos el nombre de la sentencia y esa se nos da automaticamente
// En cambio, solo necesitamos describir la condicion en el arbol de expresiones
//Para esto dividi a\u00c3\u00ban mas la gramatica para agregar los elementos de la condici\u00c3\u00b3n
//
void Ciclo_RepitoHastaQue():{/*@bgen(jjtree) Ciclo_RepitoHastaQue */
  ASTCiclo_RepitoHastaQue jjtn000 = new ASTCiclo_RepitoHastaQue(JJTCICLO_REPITOHASTAQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Ciclo_RepitoHastaQue */
         try {
/*@egen*/
	 <CicloIterado>   <ParenIzq> Condicion_RepitoHQ() <ParenDer> <ASIGNACION> 
	<SepIzq> (sentencias())* <SepDer> (<PuntoComa>|errorFinlinea())/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

//Aqui en la condicion necesitamos describir en su propia clase los lexemas de los tokens
//	Dividi la condicion asi para:
//		* Obtener el nombre de la gramatica como un subnodo, y que se imprima en el arbol
//		* Darles a los nodos hijos de la condicion (inicio y limitefinal) su propia gramatica
//		* Ya no necesito usar Token t; para el ---> jjtThis.setName(t.image);
//		* Ya lo hara automaticamente las gramaticas auxiliares
void Condicion_RepitoHQ():{/*@bgen(jjtree) Condicion_RepitoHQ */
  ASTCondicion_RepitoHQ jjtn000 = new ASTCondicion_RepitoHQ(JJTCONDICION_REPITOHQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Condicion_RepitoHQ */
 try {
/*@egen*/
 Condi_inicio() <COMA> Condi_limite()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/ 
}


void Condi_inicio():{/*@bgen(jjtree) Condi_inicio */
  ASTCondi_inicio jjtn000 = new ASTCondi_inicio(JJTCONDI_INICIO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Condi_inicio */
try {
/*@egen*/

Variable_IDEN()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

void Condi_limite():{/*@bgen(jjtree) Condi_limite */
  ASTCondi_limite jjtn000 = new ASTCondi_limite(JJTCONDI_LIMITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Condi_limite */
        try {
/*@egen*/

	(Variable_IDEN()|DataType())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}
//----------------------------------------------------------------------------------------------------------------------

 void Ciclo_RepitoMientras():{/*@bgen(jjtree) Ciclo_RepitoMientras */
  ASTCiclo_RepitoMientras jjtn000 = new ASTCiclo_RepitoMientras(JJTCICLO_REPITOMIENTRAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Ciclo_RepitoMientras */
        try {
/*@egen*/
	<CicloLimit> <ASIGNACION> <SepIzq> 
	(sentencias())* 
	<SepDer> <CicloWhile> <ParenIzq> OpComparacion() <ParenDer> (<PuntoComa>|errorFinlinea())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

//----------------------------------------------------------------------------------------------------------------------
// DECLARACION DE VARIABLES //
//----------------------------------------------------------------------------------------------------------------------
void Declaracion():
{/*@bgen(jjtree) Declaracion */
        ASTDeclaracion jjtn000 = new ASTDeclaracion(JJTDECLARACION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/   //ANALIZADOR SEMANTICO, AUN NO
//*********************************
	//Este int almacena el id del token. Su identificador dentro de la tabla de lexemas
	int td;
}
{/*@bgen(jjtree) Declaracion */
  try {
/*@egen*/ 	//COMENTARIOS PARA EL ARBOL SINTACTICO
	//Cada que el analizador encuentre una SENTENCIA tipo declaraci\u00c3\u00b3n, va a tomar el token IDENTIFICADOR
	// Y con ello datos como su id dentro de la tabla de simbolos o su valor string ej. num1, nombre_usuario
  Variable_dato(){

	//Se declara la variable t para manejar los objetos token (lexemas)
    Token t;
	
	//NO ES IMPORTANTE, ES PARA EL ANALIZADOR SEMANTICO
	//Cuando se lee un token, se almacena su id dentro de td
	//token.kind nos retorna el id del lexema en la tabla de simbolos
	td = token.kind;
  } 
//ARBOL SINTACTICO
//El token identificado (objeto tipo token), es almacenado dentro de t. Ya tenemos los datos dentro del lexema
// se asigna el nombre de la variable (el lexema, en este caso <IDENTIFICADOR>) 
//dentro de un objeto Token para ser impresO en el \u00c3\u00a1rbol en la siguiente linea 
  t = <IDENTIFICADOR> 
   {
	
	// Aqui el string del identificador (v1, num, i, etc.) es guardado en una clase con el mismo nombre de
   // la gramatica mas el prefijo 'AST': ASTDeclaracion.java <---- Aqui se crearan peque\u00c3\u00b1os metodos para realizar la asignaci\u00c3\u00b3n
   //Es importante crear estos metodos porque, por si mismo no existe el metodo .setName(), este debe ser creado manualmente
	jjtn000.setName(t.image);
	
	//Esta variable es para el proceso del analizador semantico, aun no es importante
	var = t;

   //******************COMENTARIOS PARA el analizador SEMANTICo, A\u00c3\u0161N NO ES IMPORTANTE*********************
	//Manda a llamar la clase semantica y su metodo para comprobar esto 
	//Retornara un string vacio o un null
	if(ClaseSemantica.checkVariable(var).equals("")){

		//Si se retorna un string vacio entonces ya ha sido declarada la variable
		errormsg = errormsg+"Error semantico en la linea " +var.beginLine +", columna "+var.beginColumn +", la variable "+ var.image + " ya  ha sido declarada \r\n";
		
		//Se suma la cantidad de sentencias incorrectas
		sentencias_inco++;
	}else{

		//Si no existe error alguno, entonces se insertan en la tabla
		ClaseSemantica.InsertarSimbolo(var,td);
	}
  }

//No es importante mostrar en el arbol los lexemas : asignacion (":") ni el puntocoma
// ya que solo son parte de la sintaxis general y no son un bloque muy importante para el pelda\u00c3\u00b1o
//en los arboles sintacticos son importantes los operadores, las variables, los valores de las variables y las reserved keys
// esto se pueden pasar de largo
  ((<ASIGNACION>  AsignacionD())|{}) (<PuntoComa> |errorFinlinea())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
} 

//----------------------------------------------------------------------------------------------------------------------

// ASIGNACION DE VALORES DESPUES DE UNA DECLARACION
//ESTRUCTURA BASICA DE LA GRAMATICA
//esto es la base 
void AsignacionD():{/*@bgen(jjtree) AsignacionD */
  ASTAsignacionD jjtn000 = new ASTAsignacionD(JJTASIGNACIOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) AsignacionD */
        try {
/*@egen*/   
	( LEER()  | Expresion() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
} 


// ASIGNACION GENERAL DE VALORES A UNA VARIABLE
void Asignacion():
{/*@bgen(jjtree) Asignacion */
        ASTAsignacion jjtn000 = new ASTAsignacion(JJTASIGNACION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 
	//Declaracion de variables Token
	// t es para el arbol
	// t2 es usado para el analizador semantico
	Token t, t2;
}
{/*@bgen(jjtree) Asignacion */
        try {
/*@egen*/  
	//Asignamos el valor del identificador de la variable en la clase ASTAsignacion
	//para que el arbol sea mostrado de la siguiente forma :
	//		 "Asignacion para el identificador: " + this.name
	t = <IDENTIFICADOR>{ 
		jjtn000.setName(t.image);
		
		//Ya lo que sigue despues es para el analizador semantico
		//Apartado del analizador semantico
		var = t;

		//Aqui se intenta buscar algo parecido: Se determina si la variable existe o ha sido declarada
		// Si no existe, entonces retornara un mensaje de error anunciando eso
		//Y ese mensaje se sumara a todos los mensajes de error existentes
	if(!(ClaseSemantica.checkVariable(var).equals(""))){
		errormsg = errormsg+ClaseSemantica.checkVariable(var);
		sentencias_inco++;

	}//Si no hay error, entonces se sigue de largo
  }  <ASIGNACION>
	( LEER() | Expresion())/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ {

		/*if(t2.kind != LEER){
			Expresiones.Convierte(expresion);
		} */


		t2 = token;
		//Se verifica que las declaraciones sean congruentes 
		//Se verifica que el tipo de variable y su dato sean del mismo tipo
		if(!(ClaseSemantica.checkAsing(var,t2).equals(" "))){
			errormsg = errormsg+ClaseSemantica.checkAsing(var,t2);
			sentencias_inco++;
		}
		expresion = " ";
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 
//---------------------------------------------------------------------------


//###### GRAMATICA PARA EXPRESIONES MATEMATICAS DESPUES DE UNA ASIGNACION O DECLARACION

//Lo importante a mostrar  dentro de esta  seccion de gramaticas seran los operadores que puedan surgir (+,-,*,/,%)
// Y se mostraran justo debajo de la estructura de las expresiones
void Expresion():{/*@bgen(jjtree) Expresion */
  ASTExpresion jjtn000 = new ASTExpresion(JJTEXPRESION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Expresion */
        try {
/*@egen*/   
	Termino() ( Mas_menos() Termino() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 



void Termino():{/*@bgen(jjtree) Termino */
  ASTTermino jjtn000 = new ASTTermino(JJTTERMINO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Termino */
        try {
/*@egen*/  
	Factor() ( MDM() Factor())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Factor():{/*@bgen(jjtree) Factor */
  ASTFactor jjtn000 = new ASTFactor(JJTFACTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Factor */
        try {
/*@egen*/
	( Menoss() Factor() ) | Primario()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
 
}

void Primario():{/*@bgen(jjtree) Primario */
  ASTPrimario jjtn000 = new ASTPrimario(JJTPRIMARIO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Primario */
        try {
/*@egen*/
	( (<ParenIzq>	Expresion() <ParenDer>)  | DataType() | Variable_IDEN())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//--------------------OPERAdores----------------------
//TODOS ESTOS TIENEN EN SUS CLASES  LA MISMA EXTRUCTURA PARA SER MOSTRADA EN EL ARBOL:
//		"Operador matematico: " + this.name

void Mas_menos():{/*@bgen(jjtree) Mas_menos */
                  ASTMas_menos jjtn000 = new ASTMas_menos(JJTMAS_MENOS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} 
{/*@bgen(jjtree) Mas_menos */
        try {
/*@egen*/
	(t = <MAS>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/{jjtn000.setName(t.image);} | t = <MENOS>/*@bgen(jjtree)*/
                                                            {
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
                                                            }
/*@egen*/ {jjtn000.setName(t.image);} )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Menoss():{/*@bgen(jjtree) Menoss */
               ASTMenoss jjtn000 = new ASTMenoss(JJTMENOSS);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Menoss */
        try {
/*@egen*/
	t = <MENOS>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.setName(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MDM(): {/*@bgen(jjtree) MDM */
             ASTMDM jjtn000 = new ASTMDM(JJTMDM);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) MDM */
try {
/*@egen*/
(t = <MULTI>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/{jjtn000.setName(t.image);}|t = <DIV>/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn000, true);
                                                   jjtc000 = false;
                                                 }
/*@egen*/{jjtn000.setName(t.image);}|t = <MODULO>/*@bgen(jjtree)*/
                                                                                         {
                                                                                           jjtree.closeNodeScope(jjtn000, true);
                                                                                           jjtc000 = false;
                                                                                         }
/*@egen*/{jjtn000.setName(t.image);})/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


// ############## OPERACIONES DE COMPARACION PARA IF O CICLOS  ####################
void OpComparacion():{/*@bgen(jjtree) OpComparacion */
  ASTOpComparacion jjtn000 = new ASTOpComparacion(JJTOPCOMPARACION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) OpComparacion */
                try {
/*@egen*/
		( FactorL() | FactorR() )/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void FactorL():{/*@bgen(jjtree) FactorL */
  ASTFactorL jjtn000 = new ASTFactorL(JJTFACTORL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FactorL */
        try {
/*@egen*/
	DataType()  Comparadores()  ( DataType() | Variable_IDEN() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FactorR():{/*@bgen(jjtree) FactorR */
  ASTFactorR jjtn000 = new ASTFactorR(JJTFACTORR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FactorR */
        try {
/*@egen*/
	Variable_IDEN()  Comparadores()  ( DataType() | Variable_IDEN() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/* NO ME GUST\u00c3\u201c AL FINAL ESTA GRAMATICA, IGNORAR
void ExpresionL():{} 
{   LOOKAHEAD(2) 
	(  FactorL() Comparadores() ExpresionL()  ) 
	  
	|  FactorL()
} */



 




//usar .bat para borrar archivos

//---------------- GRAMATICAS AUXILIARES ----------------------------
//Para cuando se necesite usar lexemas y no consumir la gramatica

void Variable_IDEN():{/*@bgen(jjtree) Variable_IDEN */
                      ASTVariable_IDEN jjtn000 = new ASTVariable_IDEN(JJTVARIABLE_IDEN);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) Variable_IDEN */
        try {
/*@egen*/
	t = <IDENTIFICADOR>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ {jjtn000.setName(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// DATOS Y OPERADORES USADOS EN SENTENCIAS
void DataType():{/*@bgen(jjtree) DataType */
                 ASTDataType jjtn000 = new ASTDataType(JJTDATATYPE);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} 
{/*@bgen(jjtree) DataType */
try {
/*@egen*/ //Tipos de datos  
	 
(t = <NUMERO>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.setName(t.image);} | t = <NUMDECIMAL>/*@bgen(jjtree)*/
                                                            {
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
                                                            }
/*@egen*/{jjtn000.setName(t.image);}  | t = <EST_LOGIC>/*@bgen(jjtree)*/
                                                                                                          {
                                                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                                                            jjtc000 = false;
                                                                                                          }
/*@egen*/{jjtn000.setName(t.image);}  | t = <CADENAS>/*@bgen(jjtree)*/
                                                                                                                                                       {
                                                                                                                                                         jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                         jjtc000 = false;
                                                                                                                                                       }
/*@egen*/ {jjtn000.setName(t.image);} )/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
} 


void Comparadores():{/*@bgen(jjtree) Comparadores */
                     ASTComparadores jjtn000 = new ASTComparadores(JJTCOMPARADORES);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t6;}
{/*@bgen(jjtree) Comparadores */
        try {
/*@egen*/
	LOOKAHEAD(3)
 t6 = <MENOR>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.setName(t6.image);} |  t6 = <MAYOR>/*@bgen(jjtree)*/
                                                           {
                                                             jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                           }
/*@egen*/ {jjtn000.setName(t6.image);} 
| t6 = <MENOR_IGUAL>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setName(t6.image);} |t6 = <MAYOR_IGUAL>/*@bgen(jjtree)*/
                                                                      {
                                                                        jjtree.closeNodeScope(jjtn000, true);
                                                                        jjtc000 = false;
                                                                      }
/*@egen*/ {jjtn000.setName(t6.image);} 
| t6 = <IGUALDAD>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setName(t6.image);} | t6 = <NOTEQ>/*@bgen(jjtree)*/
                                                              {
                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                jjtc000 = false;
                                                              }
/*@egen*/ {jjtn000.setName(t6.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/  
}



void LEER():{/*@bgen(jjtree) LEER */
              ASTLEER jjtn000 = new ASTLEER(JJTLEER);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;} 
{/*@bgen(jjtree) LEER */
        try {
/*@egen*/   
	t = <LEER>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setName(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
} 

void Variable_dato():{/*@bgen(jjtree) Variable_dato */
                      ASTVariable_dato jjtn000 = new ASTVariable_dato(JJTVARIABLE_DATO);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t5;} 
{/*@bgen(jjtree) Variable_dato */
        try {
/*@egen*/ //Tipo del dato de la variable del dato a la hora de su declaracion
	LOOKAHEAD(3) 
t5= <ENTERO>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/   {jjtn000.setName(t5.image);}
|t5=<FLOTANTE>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/   {jjtn000.setName(t5.image);}
|t5=<ID_CADENA>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setName(t5.image);}
|t5=<BOOLEANO>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/  {jjtn000.setName(t5.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 



void Operadores():{/*@bgen(jjtree) Operadores */
  ASTOperadores jjtn000 = new ASTOperadores(JJTOPERADORES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Operadores */
        try {
/*@egen*/ //Operadores para expresiones matematicas
	LOOKAHEAD(3)
 <MAS> 
|<MENOS>  
|<DIV> 
|<MODULO>   
|<MULTI>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/   
} 




// ---------------------------------------- TRATAMIENTO DE ERRORES --------------------------------------------------------
JAVACODE
void error_skipto(int puntocoma, int fincode, int finfile) {/*@bgen(jjtree) error_skipto */
ASTerror_skipto jjtn000 = new ASTerror_skipto(JJTERROR_SKIPTO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
  Token t;
  sentencias_inco++;
  // consume tokens all the way up to a token of "kind" - use a do-while loop
  // rather than a while because the current token is the one immediately before
  // the erroneous token (in our case the token immediately before what should
  // have been "if"/"while".
  do {
    t = getNextToken();
  }
  while ( (t.kind !=puntocoma)&&(t.kind !=fincode)&&(t.kind !=finfile));/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void error():  
{/*@bgen(jjtree) error */
        ASTerror jjtn000 = new ASTerror(JJTERROR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String errores = " "; 
	Token t;
} 
{/*@bgen(jjtree) error */
        try {
/*@egen*/  
	t = <UNKNOW>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{ 
	errores = "Simbolo: " + t.image + " no reconocido en la l\u00c3\u00adnea "+String.valueOf(t.beginLine)+" columna "+String.valueOf(t.endColumn)+"\r\n"; 
	errormsg = errormsg+errores; 
	sentencias_inco++;
}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

 
void errorFinlinea():{/*@bgen(jjtree) errorFinlinea */
        ASTerrorFinlinea jjtn000 = new ASTerrorFinlinea(JJTERRORFINLINEA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+(token.endColumn+1)+" falta ';'");
}{/*@bgen(jjtree) errorFinlinea */
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	 
	{}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
	 
}
void errorDOBLElinea():{/*@bgen(jjtree) errorDOBLElinea */
        ASTerrorDOBLElinea jjtn000 = new ASTerrorDOBLElinea(JJTERRORDOBLELINEA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+(token.endColumn+1)+" hay mas de un ';'  ");
}{/*@bgen(jjtree) errorDOBLElinea */
         try {
/*@egen*/
	 
	 <PuntoComa>/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/  
}


//GRAMATICAS DE ERROR PARA LA ESTRUCTURA DEL CODIGO COATL

void ErrorNoinicio():{/*@bgen(jjtree) ErrorNoinicio */
        ASTErrorNoinicio jjtn000 = new ASTErrorNoinicio(JJTERRORNOINICIO);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+getToken(1).beginLine+" Columna: "+getToken(1).endColumn+": No hay palabra de arranque \"compilar_coatl\" ");
}{/*@bgen(jjtree) ErrorNoinicio */
          try {
/*@egen*//*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	 
	  {}/*@bgen(jjtree)*/
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/ 
}

void ErrorNoSepINICIO():{/*@bgen(jjtree) ErrorNoSepINICIO */
        ASTErrorNoSepINICIO jjtn000 = new ASTErrorNoSepINICIO(JJTERRORNOSEPINICIO);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+getToken(1).beginLine+" Columna: "+getToken(1).beginColumn+" No hay llave izquierda \"{\" ");
	sentencias_inco++;
}{/*@bgen(jjtree) ErrorNoSepINICIO */
          try {
/*@egen*//*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	 
	  {}/*@bgen(jjtree)*/
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/ 
}
void ErrorNoSepFINAL():{/*@bgen(jjtree) ErrorNoSepFINAL */
        ASTErrorNoSepFINAL jjtn000 = new ASTErrorNoSepFINAL(JJTERRORNOSEPFINAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+token.beginColumn+": No hay llave derecha \"}\"");
}{/*@bgen(jjtree) ErrorNoSepFINAL */
          try {
/*@egen*//*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	 
	  {}/*@bgen(jjtree)*/
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/ 
}
void ErrorNOFIN():{/*@bgen(jjtree) ErrorNOFIN */
        ASTErrorNOFIN jjtn000 = new ASTErrorNOFIN(JJTERRORNOFIN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+token.beginColumn+" No hay palabra de cierre\"ejecutar_coatl\"" );
}{/*@bgen(jjtree) ErrorNOFIN */
          try {
/*@egen*//*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	 
	  {}/*@bgen(jjtree)*/
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/ 
}
